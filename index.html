<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive D3 Glitter Field</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load D3.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <!-- Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        /* Custom styles for D3 elements and controls */
        .font-inter { font-family: 'Inter', sans-serif; }
        .control-btn {
            width: 24px; height: 24px; padding: 0; display: flex; align-items: center; justify-content: center;
            background-color: #ede9fe; color: #6d28d9; border-radius: 9999px; font-weight: bold; line-height: 1;
            transition: all 150ms ease-in-out;
        }
        .control-btn:hover { background-color: #d8b4fe; }
        .control-btn:active { background-color: #a78bfa; }
        .control-btn:disabled { opacity: 0.5; cursor: not-allowed; background-color: #e5e7eb; color: #9ca3af; }
        input[type=range] { -webkit-appearance: none; width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: #9f7aea; cursor: pointer; box-shadow: 0 0 5px rgba(159, 122, 234, 0.8);
        }
        .axis line, .axis path { stroke: #7f8c8d; }
        .axis text { fill: #7f8c8d; font-size: 10px; }
        .glitter-container {
            height: 60vh; min-height: 350px; border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); overflow: hidden; position: relative;
        }
        .section-header { margin-top: 8px; border-bottom: 1px solid #e5e7eb; }
        .axis-label { fill: #7f8c8d; font-size: 12px; }
    </style>
</head>
<body class="bg-gray-100 flex h-screen overflow-hidden font-inter">

    <!-- Control Panel (Sidebar) -->
    <div id="control-panel" class="w-80 bg-white shadow-2xl p-6 border-r border-gray-200 overflow-y-auto">
        
        <h2 class="text-2xl font-bold mb-4 text-gray-800">Control Panel</h2>
        
        <!-- Dynamic Title and Description Inputs -->
        <div class="space-y-4 pb-6 border-b border-gray-200 mb-6">
            <div>
                <label for="canvasTitleInput" class="text-sm font-medium text-gray-700 block mb-1">Canvas Title</label>
                <input type="text" id="canvasTitleInput" oninput="updateVisualization(); updateTitle()" 
                       class="w-full p-2 border border-gray-300 rounded-lg text-sm focus:ring-purple-500 focus:border-purple-500">
            </div>
            <div>
                <label for="canvasDescriptionInput" class="text-sm font-medium text-gray-700 block mb-1">Canvas Description</label>
                <textarea id="canvasDescriptionInput" rows="2" oninput="updateVisualization(); updateTitle()"
                          class="w-full p-2 border border-gray-300 rounded-lg text-sm focus:ring-purple-500 focus:border-purple-500"></textarea>
            </div>
        </div>

        <!-- Collapsible Section: Particle Parameters -->
        <div id="particle-params-section"></div>
        <!-- Collapsible Section: Visualization Display -->
        <div id="vis-display-section"></div>
        <!-- Collapsible Section: Boundary Object -->
        <div id="boundary-object-section"></div>
        <!-- Collapsible Section: Visualization Axes -->
        <div id="vis-axes-section"></div>
        <!-- Collapsible Section: Visualization Annotations -->
        <div id="vis-annotations-section"></div>
    </div>

    <!-- Visualization Area -->
    <div id="main-content" class="flex-grow p-8 flex flex-col items-center justify-center overflow-auto">
        
        <!-- Dynamic Title Display -->
        <div class="text-center mb-8 w-full max-w-4xl">
            <h1 id="canvas-title-display" class="text-3xl sm:text-4xl font-extrabold text-purple-700"></h1>
            <p id="canvas-description-display" class="text-gray-600 mt-2 text-lg"></p>
        </div>
        
        <!-- D3 Visualization Container -->
        <div id="d3-container" class="glitter-container w-full max-w-4xl">
            <!-- D3 SVG will be appended here -->
        </div>
    </div>

    <script>
        // --- D3 VISUALIZATION LOGIC (Pure JS) ---

        // D3 Constants
        const CONTAINER_HEIGHT = 350;
        const VIEWBOX_WIDTH = 1000;
        const MARGIN = { top: 20, right: 20, bottom: 40, left: 50 };
        const DRAW_WIDTH = VIEWBOX_WIDTH - MARGIN.left - MARGIN.right;
        const DRAW_HEIGHT = CONTAINER_HEIGHT - MARGIN.top - MARGIN.bottom;
        const CENTER_RADIUS = 40;

        // Global State (Replaces React useState)
        let state = {
            canvasTitle: "Interactive Skewed Glitter Field",
            canvasDescription: "Adjust the parameters in the control panel to see real-time particle dynamics.",
            isParticleOpen: true,
            isVisOpen: true,
            isBoundaryOpen: false,
            isAxesOpen: false,
            isAnnotationsOpen: true,

            hSpread: 400,
            vSpread: 60,
            densitySkew: 3.0,
            particleCount: 50,
            particleDuration: 1000, // ms
            colorDiversity: 0.0,
            xOffset: 0,
            yOffset: 0,
            xBias: 0.0,
            yBias: 0.0,

            zoomLevel: 1.0,
            bgLightness: 5,

            isRectangleVisible: false,
            rectWidth: 500,
            rectHeight: 200,

            xAxisMin: -500,
            xAxisMax: 500,
            yAxisMin: -175,
            yAxisMax: 175,
            xAxisUnit: 'Integers',
            yAxisUnit: 'Integers',
            isXAxisVisible: false,
            isYAxisVisible: false,

            labels: [
                { id: 1, text: 'H-Spread ($S_H$)', valueSource: 'hSpread', visible: true, x: 700, y: 30, color: '#3498db' },
                { id: 2, text: 'Double V-Spread', valueSource: '2 * vSpread', visible: true, x: 700, y: 55, color: '#2ecc71' },
            ],
            nextLabelId: 3,
        };
        
        // D3 Element References
        let svg, g, axisRoot, particleGroup, annotationGroup, interval;

        /** Utility Functions **/

        // Helper to evaluate the user-defined equation string safely
        const evaluateEquation = (equation, scope) => {
            try {
                // Safely evaluate the expression using the scope variables
                const func = new Function(...Object.keys(scope), `return ${equation};`);
                const result = func(...Object.values(scope));

                if (isNaN(result) || !isFinite(result)) {
                    return "Err";
                }
                return parseFloat(result).toFixed(1);
            } catch (e) {
                return "Err";
            }
        };

        // Helper to generate particle data
        const generateParticleData = (s) => {
            const { 
                particleCount, hSpread, vSpread, densitySkew, colorDiversity, 
                xBias, yBias, centerX, centerY 
            } = s;

            const data = [];
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const densityFactor = Math.pow(Math.random(), densitySkew); 
                const radius = densityFactor; 

                // Calculate elliptical coordinates
                const x = centerX + radius * hSpread * Math.cos(angle) * (1 + xBias);
                const y = centerY + radius * vSpread * Math.sin(angle) * (1 + yBias);

                // Generate color (Hue fixed to purple/blue range, Saturation varied)
                const hue = 240 + Math.random() * 60; // 240 (Blue) to 300 (Purple)
                const saturation = 50 + Math.random() * (colorDiversity * 50);
                const color = `hsl(${hue}, ${saturation}%, 65%)`;

                // Generate size
                const size = Math.random() * 3 + 1;

                data.push({ id: i, x, y, color, size, radius });
            }
            return data;
        };

        /** Core Visualization Functions **/

        // 1. D3 Initialization (Runs once on load)
        const initializeD3 = () => {
            const container = d3.select("#d3-container");

            // 1. Create SVG
            svg = container.append("svg")
                .attr("viewBox", `0 0 ${VIEWBOX_WIDTH} ${CONTAINER_HEIGHT}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            // 2. Define Clip Path
            svg.append("defs").append("clipPath")
                .attr("id", "clip-rect")
                .append("rect")
                .attr("id", "clip-rect-shape");

            // 3. Axis Root Group (Not affected by zoom)
            axisRoot = svg.append("g").attr("id", "axis-root");

            // Initialize axis groups
            axisRoot.append("g")
                .attr("id", "x-axis-group")
                .attr("class", "x axis")
                .attr("transform", `translate(${MARGIN.left}, ${CONTAINER_HEIGHT - MARGIN.bottom})`)
                .style("display", "none");
            axisRoot.append("text")
                .attr("id", "x-axis-label")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("font-size", 12);

            axisRoot.append("g")
                .attr("id", "y-axis-group")
                .attr("class", "y axis")
                .attr("transform", `translate(${MARGIN.left}, ${MARGIN.top})`)
                .style("display", "none");
            axisRoot.append("text")
                .attr("id", "y-axis-label")
                .attr("class", "axis-label")
                .attr("font-size", 12);

            // 4. Main Content Group (Affected by zoom)
            g = svg.append("g").attr("id", "main-content-group");

            // Clipping background rectangle (used to show the clip area)
            g.append("rect")
                .attr("id", "boundary-rect-shape")
                .attr("fill", "none")
                .attr("stroke", "#e74c3c")
                .attr("stroke-dasharray", "5,5")
                .attr("stroke-width", 2)
                .style("display", "none"); 

            // Central object (circle)
            g.append("circle")
                .attr("id", "central-object")
                .attr("r", CENTER_RADIUS)
                .attr("fill", "#2c3e50")
                .attr("stroke", "#7f8c8d")
                .attr("stroke-width", 2)
                .attr("opacity", 0.9);

            // Group for particles
            particleGroup = g.append("g").attr("id", "particle-group");

            // Group for annotations
            annotationGroup = g.append("g").attr("id", "annotation-group");

            updateVisualization();
            startAnimationLoop();
        };

        // 2. Static Visualization Updates (Axes, Annotations, Zoom, Clipping)
        const updateVisualization = () => {
            if (!svg || !g || !axisRoot) return;
            
            // Effective center point based on offsets
            const centerX = DRAW_WIDTH / 2 + state.xOffset;
            const centerY = DRAW_HEIGHT / 2 + state.yOffset;

            // Prepare the scope object for equation evaluation
            const currentScope = {
                hSpread: state.hSpread, 
                vSpread: state.vSpread, 
                DENSITY_SKEW_EXPONENT: state.densitySkew, 
                particleCount: state.particleCount, 
                particleDuration: state.particleDuration, 
                colorDiversity: state.colorDiversity, 
                xOffset: state.xOffset, 
                yOffset: state.yOffset, 
                xBias: state.xBias, 
                yBias: state.yBias, 
                zoomLevel: state.zoomLevel, 
                bgLightness: state.bgLightness, 
                rectWidth: state.rectWidth, 
                rectHeight: state.rectHeight,
            };

            // --- SCALES AND AXES SETUP ---
            const xScaleBase = d3.scaleLinear()
                .domain([state.xAxisMin, state.xAxisMax])
                .range([0, DRAW_WIDTH]);
            
            const yScaleBase = d3.scaleLinear()
                .domain([state.yAxisMin, state.yAxisMax])
                .range([DRAW_HEIGHT, 0]);

            const xAxis = d3.axisBottom(xScaleBase).ticks(5).tickSizeOuter(0);
            const yAxis = d3.axisLeft(yScaleBase).ticks(5).tickSizeOuter(0);

            // 1. Apply Zoom Level to the main content group
            const zoomTransform = `scale(${state.zoomLevel})`;
            const translateToCenter = `translate(${DRAW_WIDTH / 2}, ${DRAW_HEIGHT / 2})`;
            const translateToMargin = `translate(${MARGIN.left}, ${MARGIN.top})`;

            g.attr("transform", `${translateToMargin} ${translateToCenter} ${zoomTransform} translate(${-DRAW_WIDTH / 2}, ${-DRAW_HEIGHT / 2})`);

            // 2. Update Central Object Position
            g.select("#central-object")
                .attr("cx", centerX)
                .attr("cy", centerY);

            // 3. Update Clipping and Boundary Rectangle
            const boundaryRectShape = g.select("#boundary-rect-shape");
            const clipRectShape = svg.select("#clip-rect-shape");

            if (state.isRectangleVisible) {
                boundaryRectShape.style("display", "block")
                    .attr("x", centerX - state.rectWidth / 2)
                    .attr("y", centerY - state.rectHeight / 2)
                    .attr("width", state.rectWidth)
                    .attr("height", state.rectHeight);

                clipRectShape
                    .attr("x", centerX - state.rectWidth / 2)
                    .attr("y", centerY - state.rectHeight / 2)
                    .attr("width", state.rectWidth)
                    .attr("height", state.rectHeight);

                particleGroup.attr("clip-path", "url(#clip-rect)");
            } else {
                boundaryRectShape.style("display", "none");
                particleGroup.attr("clip-path", null);
            }

            // 4. Update Axes
            const xAxisGroup = axisRoot.select("#x-axis-group");
            const yAxisGroup = axisRoot.select("#y-axis-group");
            const xAxisLabel = axisRoot.select("#x-axis-label");
            const yAxisLabel = axisRoot.select("#y-axis-label");

            if (state.isXAxisVisible) {
                xAxisGroup.call(xAxis).style("display", "block");
                xAxisLabel
                    .attr("x", VIEWBOX_WIDTH / 2)
                    .attr("y", CONTAINER_HEIGHT - 5)
                    .text(state.xAxisUnit)
                    .style("display", state.xAxisUnit ? "block" : "none");
            } else {
                xAxisGroup.style("display", "none");
                xAxisLabel.style("display", "none");
            }

            if (state.isYAxisVisible) {
                yAxisGroup.call(yAxis).style("display", "block");
                yAxisLabel
                    .attr("transform", `translate(15, ${CONTAINER_HEIGHT / 2}) rotate(-90)`)
                    .attr("text-anchor", "middle")
                    .text(state.yAxisUnit)
                    .style("display", state.yAxisUnit ? "block" : "none");
            } else {
                yAxisGroup.style("display", "none");
                yAxisLabel.style("display", "none");
            }
            
            // Update container background color
            d3.select("#d3-container").style("background-color", `hsl(240, 10%, ${state.bgLightness}%)`);

            // 5. Update Annotations
            const annotation = annotationGroup.selectAll("text.annotation")
                .data(state.labels.filter(d => d.visible), d => d.id);
                
            annotation.enter().append("text")
                .attr("class", "annotation text-xs font-mono")
                .merge(annotation)
                .attr("x", d => d.x)
                .attr("y", d => d.y)
                .attr("fill", d => d.color)
                .text(d => `${d.text}: ${evaluateEquation(d.valueSource, currentScope)}`)
                .style("display", "block")
                .attr("font-weight", "bold");

            annotation.exit().remove();
        };

        // 3. Particle Animation Loop
        const animateParticles = () => {
            if (!particleGroup) return;

            const particleState = {
                hSpread: state.hSpread, vSpread: state.vSpread, densitySkew: state.densitySkew, colorDiversity: state.colorDiversity, 
                xBias: state.xBias, yBias: state.yBias, 
                centerX: DRAW_WIDTH / 2 + state.xOffset, 
                centerY: DRAW_HEIGHT / 2 + state.yOffset
            };
            
            const particleData = generateParticleData(particleState);

            const circles = particleGroup.selectAll("circle.particle")
                .data(particleData, d => d.id);

            // ENTER selection: Create new circles
            circles.enter().append("circle")
                .attr("class", "particle")
                .attr("cx", particleState.centerX) // Start at the center
                .attr("cy", particleState.centerY)
                .attr("r", 0) // Start with zero radius
                .attr("fill", d => d.color)
                .attr("opacity", 1)
                .merge(circles) // Merge enter and update selections for transition
                .transition()
                .duration(state.particleDuration * 0.9)
                .ease(d3.easeLinear)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", d => d.size)
                .attr("opacity", 0) // Fade out
                .remove(); // Remove circles after the transition finishes
        };

        const startAnimationLoop = () => {
            if (interval) clearInterval(interval);
            animateParticles();
            interval = setInterval(animateParticles, state.particleDuration);
        };

        /** UI Rendering and Event Handlers **/

        // Update main titles
        const updateTitle = () => {
            state.canvasTitle = document.getElementById('canvasTitleInput').value;
            state.canvasDescription = document.getElementById('canvasDescriptionInput').value;
            document.getElementById('canvas-title-display').textContent = state.canvasTitle;
            document.getElementById('canvas-description-display').textContent = state.canvasDescription;
        };

        // Generic handler for sliders and text inputs
        const handleValueChange = (key, parseFunc) => (e) => {
            let value = e.target.value;
            if (parseFunc === parseFloat) {
                value = parseFloat(value);
            } else if (parseFunc === parseInt) {
                value = parseInt(value, 10);
            }
            state[key] = value;
            
            // Specific action for duration to restart loop
            if (key === 'particleDuration') {
                startAnimationLoop();
            }

            updateVisualization();
            renderUI(); // Re-render collapsible states
        };

        // Handler for increment/decrement buttons
        const handleButtonChange = (key, step) => () => {
            const current = state[key];
            const newValue = parseFloat((current + step).toFixed(2));
            
            // Simple clamping based on element attributes
            const input = document.getElementById(key);
            const min = input ? parseFloat(input.min) : -Infinity;
            const max = input ? parseFloat(input.max) : Infinity;

            if (newValue >= min && newValue <= max) {
                state[key] = newValue;
                
                if (key === 'particleDuration') {
                    startAnimationLoop();
                }

                updateVisualization();
                renderUI(); 
            }
        };

        // General Collapsible Functionality
        const toggleSection = (key) => () => {
            state[key] = !state[key];
            renderUI();
        };

        // Annotation CRUD Handlers
        const addLabel = () => {
            state.labels.push({ 
                id: state.nextLabelId++, 
                text: 'New Variable', 
                valueSource: 'hSpread', 
                visible: true, 
                x: 700, 
                y: 30 + (state.nextLabelId) * 25, 
                color: `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`
            });
            state.isAnnotationsOpen = true;
            updateVisualization();
            renderUI();
        };

        const updateLabel = (id, field, value) => {
            state.labels = state.labels.map(label => 
                label.id === id ? { ...label, [field]: value } : label
            );
            updateVisualization();
            renderUI();
        };

        const removeLabel = (id) => {
            state.labels = state.labels.filter(label => label.id !== id);
            updateVisualization();
            renderUI();
        };

        // --- UI COMPONENT CREATORS (For Native JS Rendering) ---

        const createControlBlock = (id, label, value, min, max, step, format = v => v, parseFunc = parseFloat) => {
            const numericMin = min !== undefined ? parseFloat(min) : -Infinity;
            const numericMax = max !== undefined ? parseFloat(max) : Infinity;
            const displayValue = Math.max(numericMin, Math.min(numericMax, value));
            
            let html = `
                <div class="space-y-2">
                    <label for="${id}" class="text-sm font-medium text-gray-700 flex justify-between items-center">
                        <span>${label}</span>
                        <div class="flex items-center space-x-2">
                            ${step ? `<button onclick="handleButtonChange('${id}', -${step})()" class="control-btn" ${value - step < numericMin ? 'disabled' : ''}>
                                <i data-lucide="minus" class="w-4 h-4"></i>
                            </button>` : ''}
                            <span class="font-mono text-purple-600 w-10 text-right">${format(displayValue)}</span>
                            ${step ? `<button onclick="handleButtonChange('${id}', ${step})()" class="control-btn" ${value + step > numericMax ? 'disabled' : ''}>
                                <i data-lucide="plus" class="w-4 h-4"></i>
                            </button>` : ''}
                        </div>
                    </label>
                    <input type="range" id="${id}" min="${min}" max="${max}" value="${value}" step="${step}" 
                           oninput="handleValueChange('${id}', ${parseFunc.name})()" class="w-full" />
                </div>
            `;
            return html;
        };

        const createCollapsibleSection = (title, contentHTML, isOpen, toggleKey, targetId) => {
            const icon = isOpen ? `<i data-lucide="chevron-right" class="w-5 h-5 transition-transform duration-300 text-purple-500"></i>` : `<i data-lucide="chevron-right" class="w-5 h-5 transition-transform duration-300 text-purple-500 rotate-90"></i>`;
            
            return `
                <div class="mb-4">
                    <button class="section-header w-full flex justify-between items-center py-2 px-2 font-semibold text-base text-gray-700 transition duration-200 rounded hover:bg-purple-50 cursor-pointer" onclick="toggleSection('${toggleKey}')()">
                        ${title}
                        ${icon}
                    </button>
                    <div id="${targetId}" class="section-content space-y-6 pt-4 px-2" style="display: ${isOpen ? 'block' : 'none'};">
                        ${contentHTML}
                    </div>
                </div>
            `;
        };
        
        // Full UI Render function (replaces React component render)
        const renderUI = () => {
            // Update Title Inputs/Display
            document.getElementById('canvasTitleInput').value = state.canvasTitle;
            document.getElementById('canvasDescriptionInput').value = state.canvasDescription;
            updateTitle();

            // --- Particle Parameters ---
            let particleContent = `
                ${createControlBlock('hSpread', 'H Spread ($S_H$)', state.hSpread, 100, 800, 10, v => v, parseInt)}
                ${createControlBlock('vSpread', 'V Spread ($S_V$)', state.vSpread, 10, 150, 5, v => v, parseInt)}
                ${createControlBlock('densitySkew', 'Radial Density Skew ($E$)', state.densitySkew, 1.0, 10.0, 0.1, v => v.toFixed(1), parseFloat)}
                ${createControlBlock('particleCount', 'Burst Count ($N$)', state.particleCount, 5, 200, 5, v => v, parseInt)}
                ${createControlBlock('particleDuration', 'Speed ($T$)', state.particleDuration, 500, 3000, 100, v => `${v / 1000}s`, parseInt)}
                ${createControlBlock('colorDiversity', 'Color Diversity ($P_{sat}$)', state.colorDiversity, 0.0, 1.0, 0.05, v => `${(v * 100).toFixed(0)}%`, parseFloat)}
                ${createControlBlock('xOffset', 'Center X-Offset (\\Delta x)', state.xOffset, -200, 200, 10, v => v, parseInt)}
                ${createControlBlock('yOffset', 'Center Y-Offset (\\Delta y)', state.yOffset, -100, 100, 10, v => v, parseInt)}
                ${createControlBlock('xBias', 'X Spread Bias (Bias_X)', state.xBias, -1.0, 1.0, 0.1, v => v.toFixed(1), parseFloat)}
                ${createControlBlock('yBias', 'Y Spread Bias (Bias_Y)', state.yBias, -1.0, 1.0, 0.1, v => v.toFixed(1), parseFloat)}
            `;
            document.getElementById('particle-params-section').innerHTML = createCollapsibleSection(
                'Particle Parameters', particleContent, state.isParticleOpen, 'isParticleOpen', 'particle-params'
            );

            // --- Visualization Display ---
            let visContent = `
                ${createControlBlock('zoomLevel', 'Zoom Level ($Z$)', state.zoomLevel, 0.5, 3.0, 0.1, v => `${v.toFixed(1)}x`, parseFloat)}
                ${createControlBlock('bgLightness', 'Background Lightness ($L_{bg}$)', state.bgLightness, 0, 20, 1, v => `${v}%`, parseInt)}
            `;
            document.getElementById('vis-display-section').innerHTML = createCollapsibleSection(
                'Visualization Display', visContent, state.isVisOpen, 'isVisOpen', 'vis-display'
            );

            // --- Boundary Object ---
            let boundaryContent = `
                <div class="flex items-center justify-between">
                    <label for="isRectangleVisible" class="text-sm font-medium text-gray-700">Enable Rectangle Boundary</label>
                    <input type="checkbox" id="isRectangleVisible" ${state.isRectangleVisible ? 'checked' : ''} 
                           onchange="state.isRectangleVisible = this.checked; updateVisualization(); renderUI();"
                           class="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500" />
                </div>
                ${createControlBlock('rectWidth', 'Boundary Width', state.rectWidth, 100, 900, 10, v => v, parseInt)}
                ${createControlBlock('rectHeight', 'Boundary Height', state.rectHeight, 50, 300, 10, v => v, parseInt)}
            `;
            document.getElementById('boundary-object-section').innerHTML = createCollapsibleSection(
                'Boundary Object (Clipping)', boundaryContent, state.isBoundaryOpen, 'isBoundaryOpen', 'boundary-object'
            );

            // --- Visualization Axes ---
            let axesContent = `
                <h4 class="text-md font-medium text-purple-600 border-b pb-1 mb-2">Horizontal (X) Axis</h4>
                <div class="flex items-center justify-between mb-2">
                    <label for="isXAxisVisible" class="text-sm font-medium text-gray-700">Enable X-Axis</label>
                    <input type="checkbox" id="isXAxisVisible" ${state.isXAxisVisible ? 'checked' : ''} 
                           onchange="state.isXAxisVisible = this.checked; updateVisualization();"
                           class="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500" />
                </div>
                <div>
                    <label for="xAxisUnit" class="text-xs font-medium text-gray-700 block mb-1">Unit Label</label>
                    <select id="xAxisUnit" onchange="state.xAxisUnit = this.value; updateVisualization();" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                        <option value="" ${state.xAxisUnit === '' ? 'selected' : ''}>(No Label)</option>
                        <option value="Years" ${state.xAxisUnit === 'Years' ? 'selected' : ''}>Years</option>
                        <option value="Integers" ${state.xAxisUnit === 'Integers' ? 'selected' : ''}>Integers</option>
                        <option value="Meters" ${state.xAxisUnit === 'Meters' ? 'selected' : ''}>Meters</option>
                    </select>
                </div>
                <div class="flex space-x-3">
                    <div class="flex-1">
                        <label for="xAxisMin" class="text-xs font-medium text-gray-700 block mb-1">Min Value</label>
                        <input type="number" id="xAxisMin" value="${state.xAxisMin}" onchange="state.xAxisMin = parseInt(this.value); updateVisualization();" class="w-full p-2 border border-gray-300 rounded-lg text-sm" />
                    </div>
                    <div class="flex-1">
                        <label for="xAxisMax" class="text-xs font-medium text-gray-700 block mb-1">Max Value</label>
                        <input type="number" id="xAxisMax" value="${state.xAxisMax}" onchange="state.xAxisMax = parseInt(this.value); updateVisualization();" class="w-full p-2 border border-gray-300 rounded-lg text-sm" />
                    </div>
                </div>

                <h4 class="text-md font-medium text-purple-600 border-b pb-1 my-3">Vertical (Y) Axis</h4>
                <div class="flex items-center justify-between mb-2">
                    <label for="isYAxisVisible" class="text-sm font-medium text-gray-700">Enable Y-Axis</label>
                    <input type="checkbox" id="isYAxisVisible" ${state.isYAxisVisible ? 'checked' : ''} 
                           onchange="state.isYAxisVisible = this.checked; updateVisualization();"
                           class="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500" />
                </div>
                <div>
                    <label for="yAxisUnit" class="text-xs font-medium text-gray-700 block mb-1">Unit Label</label>
                    <select id="yAxisUnit" onchange="state.yAxisUnit = this.value; updateVisualization();" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                        <option value="" ${state.yAxisUnit === '' ? 'selected' : ''}>(No Label)</option>
                        <option value="Percentage" ${state.yAxisUnit === 'Percentage' ? 'selected' : ''}>Percentage</option>
                        <option value="Temperature" ${state.yAxisUnit === 'Temperature' ? 'selected' : ''}>Temperature (\\deg\\text{C})</option>
                        <option value="Integers" ${state.yAxisUnit === 'Integers' ? 'selected' : ''}>Integers</option>
                    </select>
                </div>
                <div class="flex space-x-3">
                    <div class="flex-1">
                        <label for="yAxisMin" class="text-xs font-medium text-gray-700 block mb-1">Min Value</label>
                        <input type="number" id="yAxisMin" value="${state.yAxisMin}" onchange="state.yAxisMin = parseInt(this.value); updateVisualization();" class="w-full p-2 border border-gray-300 rounded-lg text-sm" />
                    </div>
                    <div class="flex-1">
                        <label for="yAxisMax" class="text-xs font-medium text-gray-700 block mb-1">Max Value</label>
                        <input type="number" id="yAxisMax" value="${state.yAxisMax}" onchange="state.yAxisMax = parseInt(this.value); updateVisualization();" class="w-full p-2 border border-gray-300 rounded-lg text-sm" />
                    </div>
                </div>
            `;
            document.getElementById('vis-axes-section').innerHTML = createCollapsibleSection(
                'Visualization Axes', axesContent, state.isAxesOpen, 'isAxesOpen', 'vis-axes'
            );

            // --- Visualization Annotations ---
            let labelsListHTML = state.labels.map(label => `
                <div class="p-2 border border-gray-200 rounded-lg bg-gray-50 space-y-1">
                    <div class="flex justify-between items-center">
                        <label class="text-xs font-medium text-gray-700 block">Annotation Text</label>
                        <button onclick="removeLabel(${label.id})" class="text-red-500 hover:text-red-700 transition">
                            <i data-lucide="x" class="w-4 h-4"></i>
                        </button>
                    </div>
                    <input type="text" value="${label.text}" onchange="updateLabel(${label.id}, 'text', this.value)"
                           class="w-full p-1 border border-gray-300 rounded-md text-xs" />
                    <label class="text-xs font-medium text-gray-700 block">Value Equation (e.g., hSpread + vSpread)</label>
                    <input type="text" value="${label.valueSource}" onchange="updateLabel(${label.id}, 'valueSource', this.value)"
                           class="w-full p-1 border border-gray-300 rounded-md text-xs font-mono" />
                    <div class="flex justify-between items-center text-xs">
                        <label>X/Y Position:</label>
                        <input type="number" value="${label.x}" onchange="updateLabel(${label.id}, 'x', parseInt(this.value))" class="w-16 p-1 border rounded-md text-xs" />
                        <input type="number" value="${label.y}" onchange="updateLabel(${label.id}, 'y', parseInt(this.value))" class="w-16 p-1 border rounded-md text-xs" />
                    </div>
                </div>
            `).join('');

            let annotationContent = `
                <div id="labels-list" class="space-y-3">${labelsListHTML}</div>
                <button id="addLabelBtn" onclick="addLabel()" class="w-full p-2 bg-purple-500 text-white font-semibold rounded-lg hover:bg-purple-600 transition duration-150 text-sm">
                    + Add New Annotation
                </button>
                <div class="text-xs text-gray-600 bg-gray-50 p-2 rounded mt-4 border border-gray-200">
                    <p class="font-semibold mb-1">Variable Legend (Use in equations):</p>
                    <ul class="list-disc list-inside space-y-0.5 ml-3">
                        <li>$S_H$: <code class="text-purple-700">hSpread</code></li>
                        <li>$S_V$: <code class="text-purple-700">vSpread</code></li>
                        <li>$E$: <code class="text-purple-700">DENSITY_SKEW_EXPONENT</code></li>
                        <li>$N$: <code class="text-purple-700">particleCount</code></li>
                        <li>$T$: <code class="text-purple-700">particleDuration</code></li>
                    </ul>
                    <p class="mt-1">Example: <code class="text-purple-700">2 * vSpread</code> or <code class="text-purple-700">hSpread + vSpread</code></p>
                </div>
            `;
            document.getElementById('vis-annotations-section').innerHTML = createCollapsibleSection(
                'Visualization Annotations', annotationContent, state.isAnnotationsOpen, 'isAnnotationsOpen', 'vis-annotations'
            );
            
            // Re-render Lucide icons if they were dynamically added
            lucide.createIcons();
        };

        // Initialize on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            renderUI();
            initializeD3();
        });

    </script>
</body>
</html>
